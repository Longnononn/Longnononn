-- Dead Rail Script by Long dzz
-- Includes: Speed, Noclip, AutoPickup, Silent Aim, ESP Zombie, Third Person View

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local hrp = character:WaitForChild("HumanoidRootPart")
local camera = Workspace.CurrentCamera

-- Biến mới cho góc nhìn thứ ba
local currentCameraOffset = Vector3.new(0, 5, 15) -- Offset mặc định ban đầu (X, Y, Z)
local minZoomDistance = 5  -- Khoảng cách zoom tối thiểu
local maxZoomDistance = 30 -- Khoảng cách zoom tối đa
local zoomSpeed = 2        -- Tốc độ zoom khi cuộn chuột

-- Biến mới cho xoay camera tự do
local cameraCFrame = camera.CFrame -- Lưu trữ CFrame hiện tại của camera khi bật chế độ scriptable
local rotationSpeed = 0.2 -- Tốc độ xoay camera

-- Update character when respawning
local function updateCharacter()
	character = player.Character or player.CharacterAdded:Wait()
	humanoid = character:WaitForChild("Humanoid")
	hrp = character:WaitForChild("HumanoidRootPart")
	if speedEnabled then humanoid.WalkSpeed = 30 end
	if thirdPersonEnabled then
		camera.CameraType = Enum.CameraType.Scriptable
		-- Cập nhật lại cameraCFrame khi nhân vật respawn để nó không bị lạc
		if hrp then
			cameraCFrame = CFrame.new(hrp.Position + currentCameraOffset) * CFrame.Angles(0, math.rad(90), 0) -- Đặt camera ngay phía sau nhân vật khi respawn
		else
			cameraCFrame = camera.CFrame -- Giữ nguyên nếu không tìm thấy hrp
		end
	else
		camera.CameraType = Enum.CameraType.Custom
	end
end
player.CharacterAdded:Connect(updateCharacter)

-- GUI (GIỮ NGUYÊN NHƯ SCRIPT GỐC BẠN ĐÃ CUNG CẤP)
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "DeadRailUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = player:WaitForChild("PlayerGui")

-- Credit (DÒNG CHỮ "script by Long dzz" GIỮ NGUYÊN)
local creditLabel = Instance.new("TextLabel")
creditLabel.Size = UDim2.new(0, 160, 0, 25)
creditLabel.Position = UDim2.new(0, 10, 0, 10)
creditLabel.BackgroundTransparency = 1
creditLabel.Text = "script by Long dzz"
creditLabel.TextColor3 = Color3.new(1, 1, 1)
creditLabel.Font = Enum.Font.Gotham
creditLabel.TextScaled = true
creditLabel.Parent = screenGui

-- Toggle button
local toggleBtn = Instance.new("TextButton")
toggleBtn.Size = UDim2.new(0, 40, 0, 40)
toggleBtn.Position = UDim2.new(0, 10, 0, 45)
toggleBtn.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
toggleBtn.Text = "+"
toggleBtn.TextScaled = true
toggleBtn.TextColor3 = Color3.new(1, 1, 1)
toggleBtn.Font = Enum.Font.GothamBlack
toggleBtn.Parent = screenGui
Instance.new("UICorner", toggleBtn)

-- Main panel
local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 160, 0, 210)
mainFrame.Position = UDim2.new(0, 60, 0, 45)
mainFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
mainFrame.Visible = false
mainFrame.Parent = screenGui
Instance.new("UICorner", mainFrame)

-- Feature toggles
local speedEnabled = false
local noclipEnabled = false
local autoAimEnabled = false
local thirdPersonEnabled = false

-- Speed button
local speedBtn = Instance.new("TextButton")
speedBtn.Size = UDim2.new(1, -20, 0, 30)
speedBtn.Position = UDim2.new(0, 10, 0, 10)
speedBtn.BackgroundColor3 = Color3.fromRGB(255, 150, 0)
speedBtn.Text = "Speed: OFF"
speedBtn.TextScaled = true
speedBtn.Font = Enum.Font.GothamBold
speedBtn.TextColor3 = Color3.new(1, 1, 1)
speedBtn.Parent = mainFrame
Instance.new("UICorner", speedBtn)

speedBtn.MouseButton1Click:Connect(function()
	speedEnabled = not speedEnabled
	if humanoid then humanoid.WalkSpeed = speedEnabled and 30 or 16 end
	speedBtn.Text = "Speed: " .. (speedEnabled and "ON" or "OFF")
	speedBtn.BackgroundColor3 = speedEnabled and Color3.fromRGB(0, 200, 0) or Color3.fromRGB(255, 150, 0)
end)

-- Noclip button
local noclipBtn = Instance.new("TextButton")
noclipBtn.Size = UDim2.new(1, -20, 0, 30)
noclipBtn.Position = UDim2.new(0, 10, 0, 50)
noclipBtn.BackgroundColor3 = Color3.fromRGB(150, 0, 255)
noclipBtn.Text = "Noclip: OFF"
noclipBtn.TextScaled = true
noclipBtn.Font = Enum.Font.GothamBold
noclipBtn.TextColor3 = Color3.new(1, 1, 1)
noclipBtn.Parent = mainFrame
Instance.new("UICorner", noclipBtn)

noclipBtn.MouseButton1Click:Connect(function()
	noclipEnabled = not noclipEnabled
	noclipBtn.Text = "Noclip: " .. (noclipEnabled and "ON" or "OFF")
	noclipBtn.BackgroundColor3 = noclipEnabled and Color3.fromRGB(0, 200, 255) or Color3.fromRGB(150, 0, 255)
end)

-- Silent Aim button
local autoAimBtn = Instance.new("TextButton")
autoAimBtn.Size = UDim2.new(1, -20, 0, 30)
autoAimBtn.Position = UDim2.new(0, 10, 0, 90)
autoAimBtn.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
autoAimBtn.Text = "Silent Aim: OFF"
autoAimBtn.TextScaled = true
autoAimBtn.Font = Enum.Font.GothamBold
autoAimBtn.TextColor3 = Color3.new(1, 1, 1)
autoAimBtn.Parent = mainFrame
Instance.new("UICorner", autoAimBtn)

autoAimBtn.MouseButton1Click:Connect(function()
	autoAimEnabled = not autoAimEnabled
	autoAimBtn.Text = "Silent Aim: " .. (autoAimEnabled and "ON" or "OFF")
	autoAimBtn.BackgroundColor3 = autoAimEnabled and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
end)

-- Third Person button
local thirdPersonBtn = Instance.new("TextButton")
thirdPersonBtn.Size = UDim2.new(1, -20, 0, 30)
thirdPersonBtn.Position = UDim2.new(0, 10, 0, 130)
thirdPersonBtn.BackgroundColor3 = Color3.fromRGB(0, 100, 255)
thirdPersonBtn.Text = "Third Person: OFF"
thirdPersonBtn.TextScaled = true
thirdPersonBtn.Font = Enum.Font.GothamBold
thirdPersonBtn.TextColor3 = Color3.new(1, 1, 1)
thirdPersonBtn.Parent = mainFrame
Instance.new("UICorner", thirdPersonBtn)

thirdPersonBtn.MouseButton1Click:Connect(function()
	thirdPersonEnabled = not thirdPersonEnabled
	if thirdPersonEnabled then
		camera.CameraType = Enum.CameraType.Scriptable
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
		-- Khởi tạo CFrame của camera dựa trên vị trí nhân vật khi bật
		if hrp then
			cameraCFrame = CFrame.new(hrp.Position + currentCameraOffset) * CFrame.Angles(0, math.rad(90), 0) -- Đặt camera ở một vị trí ban đầu phía sau nhân vật
		else
			cameraCFrame = camera.CFrame -- Fallback nếu không có hrp
		end
	else
		camera.CameraType = Enum.CameraType.Custom
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end
	thirdPersonBtn.Text = "Third Person: " .. (thirdPersonEnabled and "ON" or "OFF")
	thirdPersonBtn.BackgroundColor3 = thirdPersonEnabled and Color3.fromRGB(0, 150, 255) or Color3.fromRGB(0, 100, 255)
end)

-- Toggle GUI
toggleBtn.MouseButton1Click:Connect(function()
	mainFrame.Visible = not mainFrame.Visible
end)

--- **CÁC TÍNH NĂNG MỚI ĐƯỢC CHỈNH SỬA Ở ĐÂY** ---

-- Xử lý Zoom camera khi cuộn chuột và Xoay camera khi di chuyển chuột
UserInputService.InputChanged:Connect(function(input, gameProcessedEvent)
	if thirdPersonEnabled then
		if input.UserInputType == Enum.UserInputType.MouseWheel then
			-- Tăng hoặc giảm khoảng cách zoom dựa trên cuộn chuột
			local zoomDirection = Vector3.new(0, 0, -input.Position.Z * zoomSpeed) -- Lấy hướng zoom theo trục Z của camera
			local newCameraCFrame = cameraCFrame * CFrame.new(zoomDirection)

			-- Giới hạn khoảng cách zoom (được ước tính)
			local distToHRP = (newCameraCFrame.Position - hrp.Position).Magnitude
			if distToHRP >= minZoomDistance and distToHRP <= maxZoomDistance then
				cameraCFrame = newCameraCFrame
			end

		elseif input.UserInputType == Enum.UserInputType.MouseMovement and not gameProcessedEvent then
			-- Xoay camera khi di chuyển chuột (Yaw và Pitch)
			local deltaX = -input.Delta.X * rotationSpeed
			local deltaY = -input.Delta.Y * rotationSpeed

			-- Xoay camera quanh trục Y (Yaw) và trục X cục bộ (Pitch)
			cameraCFrame = cameraCFrame * CFrame.Angles(0, deltaX, 0)
			-- Giới hạn góc pitch: Lấy góc pitch hiện tại, điều chỉnh, rồi áp dụng lại
			local currentPitch, _, _ = cameraCFrame:ToOrientation()
			local newPitch = currentPitch + deltaY
			newPitch = math.clamp(newPitch, math.rad(-80), math.rad(80))

			-- Tạo CFrame mới với pitch đã giới hạn (giữ nguyên yaw và roll)
			local _, currentYaw, currentRoll = cameraCFrame:ToOrientation()
			local correctedCFrame = CFrame.new(cameraCFrame.Position) * CFrame.Angles(newPitch, currentYaw, currentRoll)
			
			cameraCFrame = correctedCFrame
		end
	end
end)


-- RunService effects (Cập nhật vị trí camera tự do)
RunService.Stepped:Connect(function()
	if noclipEnabled and character then
		for _, part in ipairs(character:GetDescendants()) do
			if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" and part.CanCollide then
				part.CanCollide = false
			end
		end
	end

	if thirdPersonEnabled and hrp then
		-- Camera không còn bám theo hrp nữa mà cập nhật trực tiếp từ cameraCFrame đã tính toán
		-- Giờ chỉ cần kiểm tra va chạm để đẩy camera ra khỏi vật thể
		local rayParams = RaycastParams.new()
		rayParams.FilterDescendantsInstances = { character }
		rayParams.FilterType = Enum.RaycastFilterType.Exclude

		local offsetFromPlayer = cameraCFrame.Position - hrp.Position
		local raycastDir = offsetFromPlayer.Unit * offsetFromPlayer.Magnitude
		local raycastOrigin = hrp.Position -- Bắn tia từ nhân vật đến vị trí camera

		local result = Workspace:Raycast(raycastOrigin, raycastDir, rayParams)

		local finalCameraCFrame = cameraCFrame
		if result then
			-- Nếu có vật cản giữa nhân vật và camera, di chuyển camera ra xa vật cản
			-- Đẩy camera lùi lại một chút từ điểm va chạm, giữ nguyên hướng nhìn
			finalCameraCFrame = CFrame.new(result.Position - raycastDir.Unit * 2) * cameraCFrame.Rotation
		end
		
		-- Cập nhật CFrame của camera. Không cần Lerp nếu muốn camera phản ứng tức thì với chuột.
		-- Nếu muốn mượt hơn thì dùng Lerp: camera.CFrame = camera.CFrame:Lerp(finalCameraCFrame, cameraSmoothness)
		camera.CFrame = finalCameraCFrame
	end
end)

--- **KẾT THÚC PHẦN CHỈNH SỬA TÍNH NĂNG** ---

-- Auto Pickup
spawn(function()
	while task.wait(0.1) do
		pcall(function()
			if not hrp then return end
			for _, item in ipairs(Workspace:GetDescendants()) do
				if item:IsA("BasePart") and item.Name:lower():find("pickup") and (item.Position - hrp.Position).Magnitude < 10 then
					firetouchinterest(hrp, item, 0)
					task.wait()
					firetouchinterest(hrp, item, 1)
				end
			end
		end)
	end
end)

-- ESP for zombies
local function createESP(part)
	if not part or not part:IsA("BasePart") or part:FindFirstChild("BoxESP") then return end
	if not part.Parent or not part.Parent:IsA("Model") or not part.Parent:FindFirstChildOfClass("Humanoid") then return end

	local box = Instance.new("BoxHandleAdornment")
	box.Name = "BoxESP"
	box.Adornee = part
	box.AlwaysOnTop = true
	box.ZIndex = 5
	box.Size = part.Size + Vector3.new(0.1, 0.1, 0.1)
	box.Color3 = Color3.fromRGB(255, 0, 0)
	box.Transparency = 0.4
	box.Parent = part
end

for _, obj in ipairs(Workspace:GetDescendants()) do
	if obj:IsA("Model") and obj:FindFirstChildOfClass("Humanoid") and obj ~= character then
		local head = obj:FindFirstChild("Head") or obj:FindFirstChildWhichIsA("BasePart")
		if head then createESP(head) end
	end
end

Workspace.DescendantAdded:Connect(function(obj)
	if obj:IsA("Model") and obj:FindFirstChildOfClass("Humanoid") and obj ~= character then
		task.wait(0.2)
		local head = obj:FindFirstChild("Head") or obj:FindFirstChildWhichIsA("BasePart")
		if head then createESP(head) end
	end
end)

-- Silent Aim Hook
local mt = getrawmetatable(game)
local old = mt.__namecall
setreadonly(mt, false)

mt.__namecall = newcclosure(function(self, ...)
	local args = { ... }
	local method = getnamecallmethod()
	if method == "Raycast" and autoAimEnabled then
		local origin = args[2]
		local direction = args[3]
		local closest, dist = nil, 100
		for _, obj in ipairs(Workspace:GetDescendants()) do
			if obj:IsA("Model") and obj:FindFirstChildOfClass("Humanoid") and obj ~= character then
				local hum = obj:FindFirstChildOfClass("Humanoid")
				if hum and hum.Health > 0 then
					local head = obj:FindFirstChild("Head") or obj:FindFirstChildWhichIsA("BasePart")
					if head then
						local d = (head.Position - origin).Magnitude
						if d < dist then
							dist = d
							closest = head
						end
					end
				end
			end
		end
		if closest then
			args[3] = (closest.Position - origin).Unit * direction.Magnitude
			return old(self, unpack(args))
		end
	end
	return old(self, ...)
end)

setreadonly(mt, true)
